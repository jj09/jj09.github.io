I""D<p><img class="aligncenter size-full wp-image-19203" src="/assets/2017/09/cpu.png" alt="CPU" width="1440" height="614" /></p>
<p>Recently we added in-memory caching to <a href="https://aka.ms/azureapp">Azure App</a>. You can try it out now on <a href="https://aka.ms/azureapp/ios">iOS</a> and <a href="https://aka.ms/azureapp/android">Android</a>!</p>
<p>It turns out <a href="http://www.go-mono.com/status/status.aspx?reference=4.5&amp;profile=4.5&amp;assembly=System.Runtime.Caching">Mono doesn't have <code>System.Runtime.Caching</code> namespace</a>, which makes it easy to implement caching for .NET apps. We had to find another way.</p>
<h3>Caching libraries for Xamarin</h3>
<p>We looked at a few libraries for caching (e.g., <a href="https://www.nuget.org/packages/MemoryCache/">MemoryCache</a> and <a href="https://github.com/akavache/Akavache/">Akavache</a>), but surprisingly none of them manage cache size and memory. They simply add items to Dictionary, and if you add too many you get <code>OutOfMemoryException</code>.</p>
<p>It may not be an issue for many applications, but in <a href="https://aka.ms/azureapp">Azure App</a> we need to take into account users who has multiple subscriptions with thousands of resources.</p>
<p>BTW: Akavache is a great library. Besides in-memory cache it also supports persistent cache, have clean APIs and a lot of great documentation.</p>
<h3>Implementing in-memory cache</h3>
<p>After browsing internets and asking people at <a href="https://xamarinchat.slack.com">Xamarin chat</a> we didn't find anything that would work for us, and we decided to implement in-memory cache by ourselves.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">InMemoryCache</span><span class="p">&lt;</span><span class="n">t</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IInMemoryCache</span><span class="p">&lt;</span><span class="n">t</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">LimitedCacheThreshold</span> <span class="p">=</span> <span class="m">1000</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">class</span> <span class="nc">Reference</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="kt">int</span> <span class="n">_hitCount</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

        <span class="k">public</span> <span class="n">DateTimeOffset</span> <span class="n">Timestamp</span>
        <span class="p">{</span>
            <span class="k">get</span><span class="p">;</span>
            <span class="k">private</span> <span class="k">set</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">T</span> <span class="n">Data</span>
        <span class="p">{</span>
            <span class="k">get</span><span class="p">;</span>
            <span class="k">private</span> <span class="k">set</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">AddRef</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">Interlocked</span><span class="p">.</span><span class="nf">Increment</span><span class="p">(</span><span class="k">ref</span> <span class="n">_hitCount</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">int</span> <span class="nf">ResetRef</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">count</span> <span class="p">=</span> <span class="n">_hitCount</span><span class="p">;</span>
            <span class="n">_hitCount</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">static</span> <span class="n">Reference</span> <span class="nf">Create</span><span class="p">(</span><span class="n">T</span> <span class="n">obj</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">Reference</span><span class="p">()</span>
            <span class="p">{</span>
                <span class="n">Timestamp</span> <span class="p">=</span> <span class="n">DateTimeOffset</span><span class="p">.</span><span class="n">Now</span><span class="p">,</span>
                <span class="n">Data</span> <span class="p">=</span> <span class="n">obj</span><span class="p">,</span>
            <span class="p">};</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="nf">Reference</span><span class="p">()</span>
        <span class="p">{</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">readonly</span> <span class="n">ConcurrentDictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">WeakReference</span><span class="p">&lt;</span><span class="n">reference</span><span class="p">&gt;&gt;</span> <span class="n">_weakCache</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">ConcurrentDictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">Reference</span><span class="p">&gt;</span> <span class="n">_limitedCache</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">ConcurrentDictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">t</span><span class="p">&gt;&gt;</span> <span class="n">_pendingTasks</span><span class="p">;</span>

    <span class="k">private</span> <span class="nf">InMemoryCache</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">_weakCache</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ConcurrentDictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">WeakReference</span><span class="p">&lt;</span><span class="n">reference</span><span class="p">&gt;&gt;(</span><span class="n">StringComparer</span><span class="p">.</span><span class="n">Ordinal</span><span class="p">);</span>
        <span class="n">_limitedCache</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ConcurrentDictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">Reference</span><span class="p">&gt;(</span><span class="n">StringComparer</span><span class="p">.</span><span class="n">Ordinal</span><span class="p">);</span>
        <span class="n">_pendingTasks</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ConcurrentDictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">t</span><span class="p">&gt;&gt;(</span><span class="n">StringComparer</span><span class="p">.</span><span class="n">Ordinal</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">IInMemoryCache</span><span class="p">&lt;</span><span class="n">t</span><span class="p">&gt;</span> <span class="nf">Create</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">InMemoryCache</span><span class="p">&lt;</span><span class="n">t</span><span class="p">&gt;();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">t</span><span class="p">&gt;</span> <span class="nf">GetOrAdd</span><span class="p">(</span><span class="kt">string</span> <span class="n">key</span><span class="p">,</span> <span class="n">DateTimeOffset</span> <span class="n">expiration</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">t</span><span class="p">&gt;&gt;</span> <span class="n">addFactory</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">WeakReference</span><span class="p">&lt;</span><span class="n">reference</span><span class="p">&gt;</span> <span class="n">cachedReference</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">_weakCache</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">out</span> <span class="n">cachedReference</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">Reference</span> <span class="n">cachedValue</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cachedReference</span><span class="p">.</span><span class="nf">TryGetTarget</span><span class="p">(</span><span class="k">out</span> <span class="n">cachedValue</span><span class="p">)</span> <span class="p">||</span> <span class="n">cachedValue</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cachedValue</span><span class="p">.</span><span class="n">Timestamp</span> <span class="p">&gt;</span> <span class="n">expiration</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">cachedValue</span><span class="p">.</span><span class="nf">AddRef</span><span class="p">();</span>
                    <span class="k">return</span> <span class="n">cachedValue</span><span class="p">.</span><span class="n">Data</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">try</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">actualValue</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_pendingTasks</span><span class="p">.</span><span class="nf">GetOrAdd</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">addFactory</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">_limitedCache</span><span class="p">.</span><span class="n">Count</span> <span class="p">&gt;</span> <span class="n">LimitedCacheThreshold</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">keysToRemove</span> <span class="p">=</span> <span class="n">_limitedCache</span>
                    <span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">item</span> <span class="p">=&gt;</span> <span class="n">Tuple</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span>
                        <span class="n">item</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="nf">ResetRef</span><span class="p">(),</span>
                        <span class="n">item</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">Timestamp</span><span class="p">,</span>
                        <span class="n">item</span><span class="p">.</span><span class="n">Key</span><span class="p">))</span>
                    <span class="p">.</span><span class="nf">ToArray</span><span class="p">()</span>
                    <span class="p">.</span><span class="nf">OrderBy</span><span class="p">(</span><span class="n">item</span> <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Item1</span><span class="p">)</span>
                    <span class="p">.</span><span class="nf">ThenBy</span><span class="p">(</span><span class="n">item</span> <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Item2</span><span class="p">)</span>
                    <span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">item</span> <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Item3</span><span class="p">)</span>
                    <span class="p">.</span><span class="nf">Take</span><span class="p">(</span><span class="n">LimitedCacheThreshold</span> <span class="p">/</span> <span class="m">2</span><span class="p">)</span>
                    <span class="p">.</span><span class="nf">ToArray</span><span class="p">();</span>

                <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">k</span> <span class="k">in</span> <span class="n">keysToRemove</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">Reference</span> <span class="n">unused</span><span class="p">;</span>
                    <span class="n">_limitedCache</span><span class="p">.</span><span class="nf">TryRemove</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="k">out</span> <span class="n">unused</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="kt">var</span> <span class="n">reference</span> <span class="p">=</span> <span class="n">Reference</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="n">actualValue</span><span class="p">);</span>
            <span class="n">_weakCache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="n">WeakReference</span><span class="p">&lt;</span><span class="n">reference</span><span class="p">&gt;(</span><span class="n">reference</span><span class="p">);</span>
            <span class="n">_limitedCache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">=</span> <span class="n">reference</span><span class="p">;</span>

            <span class="k">return</span> <span class="n">actualValue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">finally</span>
        <span class="p">{</span>
            <span class="n">Task</span><span class="p">&lt;</span><span class="n">t</span><span class="p">&gt;</span> <span class="n">unused</span><span class="p">;</span>
            <span class="n">_pendingTasks</span><span class="p">.</span><span class="nf">TryRemove</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">out</span> <span class="n">unused</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>We use two layers of caching. First is using <code>WeakReference</code> that leaves memory management to Garbage Collector. As GC is not very predictable and sometimes may unnecessary release some reference, we have second layer of caching. We call it <code>_limitedCache</code>, and it keeps objects in memory until capacity reach 1000 objects. Then we remove half (500), least used objects from dictionary. Because the same objects are being kept in two dictionaries, the <code>WeakReference</code> will never be released as long as object is in <code>_limitedCache</code>. Thus, we always check only if object is present in <code>_weakCache</code>.</p>
<p>There is also third dictionary that keeps track of pending tasks that are responsible for getting data. This prevents us from sending the same requests more than once if object is not in cache yet.</p>
<h3>Summary</h3>
<p>What is great about building apps with Xamarin is the ability to share code across platforms. When we were implementing cache, we didn't touch any platform specific code. All work was done in <a href="https://developer.xamarin.com/guides/cross-platform/application_fundamentals/pcl/introduction_to_portable_class_libraries/">Portable Class Library</a>.</p>
<p>Adding cache to <a href="https://aka.ms/azureapp">Azure App</a> helped not only to decrease user's network data usage, but also to improve performance significantly!</p>
<p>If you need in-memory cache for your app, go ahead and use the above code snippet! If you are looking for persistent cache then consider using <a href="https://github.com/akavache/Akavache/">Akavache</a>.</p>
<p>Are you caching? How? Why? Why not?</p>
:ET